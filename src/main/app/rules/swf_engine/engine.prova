rcvMsg(XID, Primitive, From, Performative, executeTask(TaskName, TaskID, Inputs, Outputs)) :-
    % register the information of a task into the task management center
    de.fub.csw.TaskManagementCenter.registerTask(TaskID, TaskName, Inputs, Outputs),
    
    % record the inputs of a task
    de.fub.csw.opm.ProvenanceRecording.recordTaskInput(XID, TaskID, Inputs),
    % allocate a task to an agent
    URL = de.fub.csw.constant.StringConstants.SEMANTIC_DATA_REPOSITORY_URL,
    sparql_connect(Connection, URL),
    %semanticDataConnection(URL, Connection),
    allocateTask(XID, TaskName, TaskID, Agent, Connection),
    
    % invoke the task  
    invokeTask(XID, TaskName, TaskID, Agent, Inputs, Outputs, Connection).
    
semanticDataConnection(URL, Connection):-
    connection(URL, Connection),
    !.
    
semanticDataConnection(URL, Connection):-
    sparql_connect(Connection, URL),
    assert(connection(URL, Connection)).

% record the outputs of a task
% remove its information from the task management center    
rcvMsg(XID, esb, From, "answer", [TaskID, [inArgs|Inputs], [outArgs|Outputs]]) :-
    de.fub.csw.opm.ProvenanceRecording.recordTaskOutput(XID, TaskID, Outputs),
   
    % distribute the message after the provenance information recording
    sendMsg(XID, async, 0, "answer", [TaskID, [inArgs|Inputs], [outArgs|Outputs]]).

allocateTask(XID, TaskName, TaskID, Agent, Connection) :-
    getResponsibleAgents(TaskID, TaskName, Agent, Connection),
    println(["The TASK: ", TaskName, "(", TaskID,") is allocated to AGENT:",Agent]).


% find the optimal agent
getResponsibleAgents(TaskID, TaskName, Agent, Connection) :-
    QueryString =  de.fub.csw.constant.StringConstants.queryAgentByTask(TaskName),
	sparql_select(Connection, QueryString, TaskID),
	sparql_results(TaskID, FullAgentName),
	getLocalName(FullAgentName, Agent)[bound(FullAgentName)],
	!.

getResponsibleAgents(TaskID, TaskName, Agent, Connection) :-
    println(["NO AVAILABLE AGENT TO TASK: ", TaskName, "(", TaskID,"). THE EXCEPTION IS FORWARED TO EXCEPTION HANDLING AGENT."]),
    sendMsg(XID,esb,exceptionHandlingAgent, "request", noAgentAvailable(TaskName, TaskID)),
    rcvMsg(XID, esb, exceptionHandlingAgent, "answer", [TaskID, Agent]).

      
invokeTask(XID, TaskName, TaskID, Agent, Inputs, Outputs, Connection) :-
    sendMsg(XID,esb, Agent, "start", [TaskName, TaskID,Inputs,Outputs]),
    checkReceipt(XID, Agent, TaskName, TaskID,Inputs,Outputs, Connection).

checkReceipt(XID, Agent, TaskName, TaskID, Inputs, Outputs, Connection):-
    rcvMsg(XID,Protocol,From, "answer" , unavailableAgent(TaskName, TaskID, Agent)),
    !,
    UpdateString =  de.fub.csw.constant.StringConstants.updateAgent(Agent),
    BASE_URL = de.fub.csw.constant.StringConstants.WF_ONTOLOGY_BASE_URL,
    sparql_update(Connection, UpdateString, BASE_URL, TaskID),
    sendMsg(XID,esb,exceptionHandlingAgent, "request", unavailableAgent(TaskName, TaskID, Agent)),
    rcvMsg(XID, esb,exceptionHandlingAgent, "answer", [TaskID, NewAgent]),
    invokeTask(XID, TaskName, TaskID, NewAgent,Inputs,Outputs).

checkReceipt(XID, Agent, TaskName, TaskID, Inputs, Outputs, Connection):-
    !,
    println(["The workflow engine is waiting for the answer from the AGENT:", Agent]).
   
    
assignTaskID(XID, TID) :-
    R = java.util.UUID.randomUUID(),
    concat([XID,"_",R],R1),
    R2 = R1.replace(":", "_"),
    TID = R2.substring(0,20).

getLocalName(FullName, LocalName) :-
    P = FullName.lastIndexOf("#"),
    math_add1(P,1,P1),
    LocalName = FullName.substring(P1).
    
    